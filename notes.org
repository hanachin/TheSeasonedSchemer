* The Seasoned Schemer
** このメモについて
   Scheme修行を読んで本文で気になった部分や感想などを書いていく。
*** TODO このメモ書きからブログを作成するためのorg-modeの使い方を覚える
** 訳者前書き
*** 2章合わせてSchemeの入門書として完結
*** The Little Schemerと同じく質問とそれに対する答えという形式
*** 前作では「再帰的」な考え方、今回は継続と代入
*** 他の言語では大域的な脱出手段としてはあるがSchemeのようにいつでも使えるわけではないらしい
** 序文
*** 「もし誰かに魚をあげたら、一日食べることができる。もし誰かに釣りを教えたら、一生食べることができる。」
*** Lispは元々「LISt Processor」Lispにはリストがなければならないが。リストはLispの心臓。
*** しかし関数も必要。関数は魂。
*** Scheme手習いは言うなれば魚。生きるためには一日の魚だけでは足りない。今度は釣りを習う番!
** はじめに
*** 「この本の目的は、読者に計算の性質について考えることを教えることにある。」
*** プログラミングの実用的な世界への入門書ではないが、計算の性質を理解する出発点
**** ガイドライン
***** 急いで読んではだめ。5回未満で読み切ろうとしないこと。(ちなみにScheme手習いには2回未満で読み切ろうとしないこと、と書いてる)
***** 飛ばして後ろから読んではだめ。少しずつ難しくなっていく。
***** 「読みながら例を試す」
****** Gaucheで試しながら進める。
****** 関数については本の中の質問を拾ってテストケースを書く。
****** なるべくテストケースを書いてから関数を定義するようにする。
***** TODO 本にちりばめられたヒントから自分の定義を形式化し、覚え、理解する!
***** しかし戒律はその先を読む前に知って理解しておくこと。
** Chapter 11
*** Scheme手習いの続きなので11から始まる。
*** 究極のλを知っていますか?
*** two-in-a-row-b?は2つの引数が変わるのに、質問は1つの引数についてのみ
**** 今までのものとちょっと違う
**** 先行する要素を引数に取っている
*** p10「一方の引数は他方の引数について関数に何かを伝えます」
**** このトリックは面白いなぁ
**** two-in-a-row-bのprecedingでは他方の引数の前の要素を
**** sum-of-prefixes-bのsonssfはこれまでの全ての数の合計を
**** scramble-bのrev-preは自分より前の部分の逆を
*** 第11の戒律「ある関数が、その関数に対する他の引数がいかなるものか知る必要があるときは、付加的な引数を用いるべし。」
*** 出てきてる用語
**** parsleyはパセリ
**** sardinesはイワシ
**** TODO tupは(なんだったっけ)
**** sonssfは「sum of numbers seen so far.(それまで見てきた数の合計)」の略
**** scrambleのニュアンスがちょっと分からない
**** rev-preはreversed prefix
*** 前章で定義したone?やpickなどの手続きを別途定義した
*** 「関数の手がかりは、いつだってその名前です。」
**** いい名前は理解を助けてくれますね。
*** 食事の回数、3回
**** p13 「覚えているならアイスクリームを食べましょう」
**** p15 「スナックを食べる前に」
**** p15 「お茶の時間です。」
**** 「はじめに」によると「食べ物がちょっとした気晴らしになってこの本を一度にたくさん読まないで済むことを願っている」らしい。
***** でも面白いから読み始めると1章、一気に読んでしまう。
** Chapter 12
*** multiremberのYコンビネータを使った定義では一番外側のlambdaでaが束縛されるのでYコンビネータに渡す関数の中でaを自由に使う事が出来る。
*** p18の動かないmrの定義
**** mrの中のaは束縛されていない自由変数
**** Schemeは静的スコープなのでmrが定義された時にaが値に束縛されてないとunbound variableとエラーが出て動かない。
**** mrを呼び出しているmultiremberの中の変数aはmrの定義時にはスコープの外、mrからはaが見えていない。
**** 試しにElispで書いたら動いた。Elispは動的スコープなので呼び出し元の環境の変数aを参照するため動く。
     (defun mr (lat)
     (cond ((null lat) '())
     ((eq a (car lat)) (mr (cdr lat)))
     (t (cons (car lat)
     (mr (cdr lat))))))
     
     (defun multirember (a lat)
     (mr lat))
     
     (multirember 'pie '(apple custard pie linzer pie torte))


*** p19にてα変換、α同値の話が出てくる。
*** p20 「(letrec ...)の名前づけ部分で定義された関数は囲まれている全ての(lambda ...)式の全ての引数を知っています。」
**** (letrec ((mr ...)) mr)はmrという名前の関数を定義して、その再帰関数を返している。
**** letrec中のmrは外側のlambdaの引数aを知っている。
*** letrecを使ったmultirember
**** mr pieを定義してlatに用いたように見える
**** p21下線のついたdefineは実際には存在しないけれどそのように想像することで理解の助けになる
**** mr pieはdefineを使って定義した関数と違って外側からは見えない!
*** 第12の戒律「再帰を適用している間に変化せぬ引数を除くには(letrec ...)を用いるべし。」
*** p23~p26でletrecを使ってmultirember-fを定義している。letrecの使い方は同じ。関数を定義して返す。
*** member?やunionなどを第12の戒律に従い書き直し。
**** member?の中のyes?で引数の名前がlなのはlatと被らないように?それとも短い名前がよかったから?
*** 関数を守る
**** unionの中のUは、unionが知っている事はすべて知っている。
**** unionの中にmember?の定義は出てこない
**** unionの動作はmember?に依存してる。member?の引数の順番が変わったら動かなくなってしまう。
**** letrecはかっこで囲んだ関数定義を複数おける。(condの条件みたいに)
**** そこで、unionの内側のletrecでmember?を定義する
*** 第13の戒律「関数を隠し、守るには、(letrec ...)を用いるべし。」
**** 補助関数はその関数にとって特別な値に使う。だから補助関数の定義が変わって変な値を返さないようにその場に隠す。
** Chapter 13
*** (hop M)に遭遇する前にすべきことだった事を全て忘れて(letcc hop M)の値を求めたかのように振る舞う
*** 戻るのを待っている計算があっても戻らないで何もしないで全て忘れて(letcc hop M)の値を求めたかのように…
*** hopと唱えて、結果と一緒に正しい場所へ
*** 第14の戒律「(letcc ...)を用いて、値を直ちに、すばやく返すべし。」
*** p45の(null? (cdr lset))の質問の答えは真?
*** p49とp50のJの中のcondのmember?とelse?の答えは逆?
*** どこかで覚えた計算を忘れる
**** intersectallは結果が何かを知っている
***** 空集合が1つでもあれば、結果は空集合
**** rember-upto-lastはリストの部分が結果に「ない」か知っている
***** リストの中にaを見つけたら、リストの残りに結果がある。前の部分には「ない」
*** consが結果を待ってるはずなのにskipしてる。面白い!
*** (let/cc skip body...)は(call/cc (lambda (skip) body...))と一緒
*** 結果をまたずに抜け出すときに使うと便利っぽい
*** プログラミングGaucheの継続の章を読まないと完全には理解出来なさそうな感じがする
*** 計算途中だった値はどこへいっちゃうんだろ
** Chapter 14
*** 同じ式が繰り返しでてくるのはまずい
**** 関数を理解するのに同じ式を2回読まないといけない
**** 関数を読んでる人が理解しづらい
**** 2回評価するからその分計算が増える
*** 繰り返される式に名前をつけるためにletを使う
**** 再帰関数に名前をつけるのにはletrecを使う
**** letrecは多分let recursiveの略、letは何の略かな?
**** letは以下のλ式のシンタックスシュガー
***** (let ((x1 α1) ... (xn αn)) β...)
***** ((lambda (x1 ... xn) β...) α1 ... αn)
***** λの仮引数x1...xnがα1...αnに束縛される
***** letrecは複数定義したのを相互に使えるけどletは駄目。α1...αnを評価している環境が違うからかな?
*** eqlist?はTheLittleSchemerで自分で定義してたけど(define eqlist? equal?)して代用
*** letrecとletを使ってrember*を定義
*** avは何の略だろう?
*** 第15の戒律(仮)「繰り返される式の値に名づくるには(let ...)を用うべし。」
**** 「名づくる」「用う」初めて見た
*** rember1*を途中までrember*に空目してた
*** p70のdepth*は書き換えてテスト実行したけど確かに通らなかった
**** lが空か分かる前に(car l)の値に依存してしまっている
*** p73のdepthは非常に読みづらい
**** 1回しか評価されないのにletで名づくるのは読みづらくなったりする
*** 第15の戒律
    「関数定義において繰り返される式は、
    当の関数を1回使用するときに2回評価される可能性があるなら、
    それらの値を名づくるに(let ...)を用うべし。」
*** if文出てきた!
**** もっと前に知っておくべきだった?「何事にも、ふさわしい時と場所があるのです。」
**** (if α β γ)は(cond (α β) (else γ))と同じ
**** condを知ってればすっとifを理解出来る。
**** 答えによって2つに分かれる時ifを使うとcondよりも読みやすくなる
*** 最初のコードから掟に従いつつ構造を考えていくと可読性があがりますね
**** 比較するために1回、値を返すためにもう1回評価してた
**** letで束縛すると2回評価しないでよくなってコードもすっきり
**** 2つに分岐するだけならifのがすっきり
**** やってることを抽象化してmaxを使えばすっきり
**** リファクタリングってこんな感じなのだろうか
*** letのbody部分に複数の式を置いてbegin的に使うなど
*** 「第14の戒律を用いるときに第13の戒律を忘れてはならない」
**** 戒律は単独ではなくセットで使う事が多い
*** letで順番よく実行してる途中で抜け出すために方位磁針skipを使う
**** 継続を取り出してからマイナー関数に渡すことで、マイナー関数の中で値が求まった時に即座に返す事が出来る!
*** letccを使ったrember1*について
**** rember1*の中で、(car l)から何も取り除けなかったら方位磁針を使って戻って来る。
**** 取り除けた時はaを取り除いたリストを作りながら戻って来る。
**** 取り除けなかった時はnoっていうアトムを持って戻って来る。
**** 取り除けたら終わり、取り除けなかったらcdrで再帰
**** 方位磁針を使う事がないと分かっている場合は、0や'()を方位磁針として渡しても大丈夫。
*** tryをマクロで書いてみた
**** (try x a b)aの中でxを使うとaを抜けて、bを返す
**** 使わずにaを終了した場合、bは実行せず即座に値を返す
** Chapter 15
*** ここに来て初めてdefineで値に名前をつける。
*** set!(セットバン)は値を返さない。defineと似たもの。Lispではsetq(セットキュー、説得)
*** set!すると名前の参照を変更出来る。あたかもxが定義されてないときにdefineで名前をつけたのと同じ。
*** lambdaの値部分に2つ式がある。letやbeginと同じ。2番目の式(最後の式)の値を返す。
*** 別々の関数で同じ名前にset!する衝突が起こりえる。それは困る。
*** lambdaをletで囲む
**** あたかも架空の名前x1をdefineしたかのよう
**** 架空の名前の値はない。
**** 架空の名前が何を表しているか覚えておかないといけない
*** 第16の戒律「(let...)で定義された名前に対してのみ、(set!...)を使うべし
*** 第17の戒律(予備版)
    (let ((x ...)) ...)に対して(set! x ...)を用いる際には
    それらの間には少なくとも1つのlambdaを置くべし
*** letとsetの間にlambdaを入れないで使っても何かを覚える役には経たない
*** 第18の戒律「(set! x ...)はxが参照する値がもはや必要ないときにのみ使うべし」
*** swap出てきた!
**** letを使って名前をつけるとその値を参照するのに2通りの方法がある
** Chapter 16
*** この章もset!ばかりで、テストどうかこう orz
**** 結局中途半端にテスト書きました。
*** deepやsweet-toothの実行結果をset!でlistに保存していく
*** 第19の戒律が出てきた。
**** 1回の呼び出し内で複数回使われる値はletで、複数回にまたがる場合はset!で覚えておく
*** deepM
**** findは値が見つかる場合に呼ばれる
***** 後ほどfindに値が見つからない場合を1行追加
**** findが呼び出せるかはあらかじめdeepMがmember?で調べる
**** この役割分担がいいなぁ
**** deepRを内側に取り込んで簡素化
*** p120まではメモ化の話かな?
*** p121、第17の戒律最終版、xの新しい値がx(自分自身?)を参照する関数のとき、が追加
*** 「架空の名前h1を通して自分自身の再帰的コピーを参照しているだけです」
*** Y!コンビネータ
**** 再帰的な部分だけ残してlengthに特徴的な部分を切り出す
**** Lに(lambda (arg) (h arg))を渡してる
***** hをそのまま渡すと(set! h (L h))になってしまう
***** それだと(L h)となり、hが先に評価される
***** 新しいhになる前のhの値そのものをLに渡してしまわないように、lambdaでくるんでる?
**** ありがとう、Peter J.Landin
     名前で検索したら
     「J演算子は継続を可能としたもので、Scheme の call/cc は J 演算子を簡略化したものである」http://ja.wikipedia.org/wiki/ISWIM
     という興味深い記述が
*** letrecはletとset!からなる式の省略らしい。letrecを使ったバージョンがY-bang
*** この流れが適用順手続き的Yコンビネータの導出、らしい
*** Y!はこの形をした全てのfに対してYと同じ再帰関数を作り出す
**** biz関数をYに適用した場合と、Y!に適用した場合とで結果が違う
**** biz関数の(lambda (a)の下に(print x)つけたら、xがずっと1のままだった。
**** biz関数の(set!の下に(print x)つけるとYは毎回表示、Y!だと1回しか表示されない
**** Yは(biz (lambda (arg) ((f f) arg)))の(f f)で自分自身を得る際で毎回bizを呼び出してる。
**** Y!は(set! hする時、1回しか(biz (lambda (arg) (h arg)))を呼び出さない
**** なのでxは1のまま。
