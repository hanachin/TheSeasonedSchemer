* The Seasoned Schemer
** このメモについて
   Scheme修行を読んで本文で気になった部分や感想などを書いていく。
*** TODO このメモ書きからブログを作成するためのorg-modeの使い方を覚える
** 訳者前書き
*** 2章合わせてSchemeの入門書として完結
*** The Little Schemerと同じく質問とそれに対する答えという形式
*** 前作では「再帰的」な考え方、今回は継続と代入
*** 他の言語では大域的な脱出手段としてはあるがSchemeのようにいつでも使えるわけではないらしい
** 序文
*** 「もし誰かに魚をあげたら、一日食べることができる。もし誰かに釣りを教えたら、一生食べることができる。」
*** Lispは元々「LISt Processor」Lispにはリストがなければならないが。リストはLispの心臓。
*** しかし関数も必要。関数は魂。
*** Scheme手習いは言うなれば魚。生きるためには一日の魚だけでは足りない。今度は釣りを習う番!
** はじめに
*** 「この本の目的は、読者に計算の性質について考えることを教えることにある。」
*** プログラミングの実用的な世界への入門書ではないが、計算の性質を理解する出発点
**** ガイドライン
***** 急いで読んではだめ。5回未満で読み切ろうとしないこと。(ちなみにScheme手習いには2回未満で読み切ろうとしないこと、と書いてる)
***** 飛ばして後ろから読んではだめ。少しずつ難しくなっていく。
***** 「読みながら例を試す」
****** Gaucheで試しながら進める。
****** 関数については本の中の質問を拾ってテストケースを書く。
****** なるべくテストケースを書いてから関数を定義するようにする。
***** TODO 本にちりばめられたヒントから自分の定義を形式化し、覚え、理解する!
***** しかし戒律はその先を読む前に知って理解しておくこと。
** Chapter 11
*** Scheme手習いの続きなので11から始まる。
*** 究極のλを知っていますか?
*** two-in-a-row-b?は2つの引数が変わるのに、質問は1つの引数についてのみ
**** 今までのものとちょっと違う
**** 先行する要素を引数に取っている
*** p10「一方の引数は他方の引数について関数に何かを伝えます」
**** このトリックは面白いなぁ
**** two-in-a-row-bのprecedingでは他方の引数の前の要素を
**** sum-of-prefixes-bのsonssfはこれまでの全ての数の合計を
**** scramble-bのrev-preは自分より前の部分の逆を
*** 第11の戒律「ある関数が、その関数に対する他の引数がいかなるものか知る必要があるときは、付加的な引数を用いるべし。」
*** 出てきてる用語
**** parsleyはパセリ
**** sardinesはイワシ
**** TODO tupは(なんだったっけ)
**** sonssfは「sum of numbers seen so far.(それまで見てきた数の合計)」の略
**** scrambleのニュアンスがちょっと分からない
**** rev-preはreversed prefix
*** 前章で定義したone?やpickなどの手続きを別途定義した
*** 「関数の手がかりは、いつだってその名前です。」
**** いい名前は理解を助けてくれますね。
*** 食事の回数、3回
**** p13 「覚えているならアイスクリームを食べましょう」
**** p15 「スナックを食べる前に」
**** p15 「お茶の時間です。」
**** 「はじめに」によると「食べ物がちょっとした気晴らしになってこの本を一度にたくさん読まないで済むことを願っている」らしい。
***** でも面白いから読み始めると1章、一気に読んでしまう。
** Chapter 12
*** multiremberのYコンビネータを使った定義では一番外側のlambdaでaが束縛されるのでYコンビネータに渡す関数の中でaを自由に使う事が出来る。
*** p18の動かないmrの定義
**** mrの中のaは束縛されていない自由変数
**** Schemeは静的スコープなのでmrが定義された時にaが値に束縛されてないとunbound variableとエラーが出て動かない。
**** mrを呼び出しているmultiremberの中の変数aはmrの定義時にはスコープの外、mrからはaが見えていない。
**** 試しにElispで書いたら動いた。Elispは動的スコープなので呼び出し元の環境の変数aを参照するため動く。
     (defun mr (lat)
     (cond ((null lat) '())
     ((eq a (car lat)) (mr (cdr lat)))
     (t (cons (car lat)
     (mr (cdr lat))))))
     
     (defun multirember (a lat)
     (mr lat))
     
     (multirember 'pie '(apple custard pie linzer pie torte))


*** p19にてα変換、α同値の話が出てくる。
*** p20 「(letrec ...)の名前づけ部分で定義された関数は囲まれている全ての(lambda ...)式の全ての引数を知っています。」
**** (letrec ((mr ...)) mr)はmrという名前の関数を定義して、その再帰関数を返している。
**** letrec中のmrは外側のlambdaの引数aを知っている。
*** letrecを使ったmultirember
**** mr pieを定義してlatに用いたように見える
**** p21下線のついたdefineは実際には存在しないけれどそのように想像することで理解の助けになる
**** mr pieはdefineを使って定義した関数と違って外側からは見えない!
*** 第12の戒律「再帰を適用している間に変化せぬ引数を除くには(letrec ...)を用いるべし。」
*** p23~p26でletrecを使ってmultirember-fを定義している。letrecの使い方は同じ。関数を定義して返す。
*** member?やunionなどを第12の戒律に従い書き直し。
**** member?の中のyes?で引数の名前がlなのはlatと被らないように?それとも短い名前がよかったから?
*** 関数を守る
**** unionの中のUは、unionが知っている事はすべて知っている。
**** unionの中にmember?の定義は出てこない
**** unionの動作はmember?に依存してる。member?の引数の順番が変わったら動かなくなってしまう。
**** letrecはかっこで囲んだ関数定義を複数おける。(condの条件みたいに)
**** そこで、unionの内側のletrecでmember?を定義する
*** 第13の戒律「関数を隠し、守るには、(letrec ...)を用いるべし。」
**** 補助関数はその関数にとって特別な値に使う。だから補助関数の定義が変わって変な値を返さないようにその場に隠す。
** Chapter 13
*** (hop M)に遭遇する前にすべきことだった事を全て忘れて(letcc hop M)の値を求めたかのように振る舞う
*** 戻るのを待っている計算があっても戻らないで何もしないで全て忘れて(letcc hop M)の値を求めたかのように…
*** hopと唱えて、結果と一緒に正しい場所へ
*** 第14の戒律「(letcc ...)を用いて、値を直ちに、すばやく返すべし。」
*** p45の(null? (cdr lset))の質問の答えは真?
*** p49とp50のJの中のcondのmember?とelse?の答えは逆?
*** どこかで覚えた計算を忘れる
**** intersectallは結果が何かを知っている
***** 空集合が1つでもあれば、結果は空集合
**** rember-upto-lastはリストの部分が結果に「ない」か知っている
***** リストの中にaを見つけたら、リストの残りに結果がある。前の部分には「ない」
*** consが結果を待ってるはずなのにskipしてる。面白い!
*** (let/cc skip body...)は(call/cc (lambda (skip) body...))と一緒
*** 結果をまたずに抜け出すときに使うと便利っぽい
*** プログラミングGaucheの継続の章を読まないと完全には理解出来なさそうな感じがする
*** 計算途中だった値はどこへいっちゃうんだろ
